# # dict = { key1:значение key 2: значение}
# users = {1:"Sam", 2:"Max",3:"tony"}
# # print(users[1]) - # получения значения из словаря, через ключ, вводишь ключ и получаешь элементы словаря

# chemelem = {"H":'Vodorod',"o":"Kislorod","C1": "Hlor"}
# print(chemelem["o"])


# объеденить в один словарь
# var 1
# dict_1 = {'a': 300, 'b': 400}
# dict_2 = {'c': 500, 'd': 600}
# dict_1.update(dict_2)
# print(dict_1)

# # var 2
# dict_1 = {'a': 300, 'b': 400}
# dict_2 = {'c': 500, 'd': 600}
# dict_3 = dict_1.copy()
# print(dict_3)
# как я понимаю copy только в формате список + список

#var 3
# dict_1 = {'a': 300, 'b': 400}
# dict_2 = {'c': 500, 'd': 600}
# dict_3 = dict_1|dict_2
# print(dict_3)

# бомбовый метод

# cловарь с числовым значение надо перемножить
# dict_1 = {'a': 100,'b': 3}
# result = 1
# for key in dict_1:
#     result = result * dict_1[key]
# print(result)

# как это случилось не понял (что такое резалт) почему я его умножаю на дикт

# создать словарь от 0 до 10 и  значения в кубе (я не понимаю суть задачи внутри словаря все умножается на куб или как)

# dict_1 = {0:0,1:1,2:2,3:3,4:4,5:5}
# не правильно по синтаксису но я не понял как прикинуть я думал
# но я понял что нужно через цикл
# dict_1 = (i * 3 for i in range(1,11))
# print(dict_1)
# почему нет правильного ответа не понятно

#1
# Данные об email-адресах студентов хранятся в словаре:
# Нужно дополнить код таким образом,
# чтобы он вывел все адреса в алфавитном порядке и в формате
# имя_пользователя@домен.
#

# dict_emails = {'mgu.edu': ['andrei_serov', 'alexander_pushkin', 'elena_belova', 'kirill_stepanov'],
#       	'gmail.com': ['alena.semyonova', 'ivan.polekhin', 'marina_abrabova'],
#       	'msu.edu': ['sergei.zharkov', 'julia_lyubimova', 'vitaliy.smirnoff'],
#       	'yandex.ru': ['ekaterina_ivanova', 'glebova_nastya'],
#       	'harvard.edu': ['john.doe', 'mark.zuckerberg', 'helen_hunt'],
#       	'mail.ru': ['roman.kolosov', 'ilya_gromov', 'masha.yashkina']}
# # email.keys = {}
# email.keys = sorted(dict_emails, key = dict_emails.get)
# print(mail.keys)

# он выдает вот такую вещь - - <generator object <genexpr> at 0x000000BB44244DD0> что это
# честно говоря сложноватая задачка особо глубинно решение не понял сейчас возьму что нибудь по легче
#


#2
#
# Даны два списка одинаковой длины. Необходимо создать из них словарь таким образом,
# чтобы элементы первого списка были ключами,
# а элементы второго — соответственно значениями нашего словаря.
#

a = ['a','b']
b = [4,2]
c = zip(a,b)
print(c)

# почему не внятный ответ все же правильно синтаксис правильный все правильно
# <zip object at 0x00000071489BBCC0> что это почему так
# вторую задачу такой ответ
#
#

# tasks 3
#
# Напишите скрипт Python для сортировки (возрастания и убывания) словаря по значению
#

a = {'a':3 , 'b':9, 'c':12, 'f':4, 's':5}
b = sorted(a.values())
print(b)


# tasks 4
#
#
# Напишите скрипт Python, чтобы проверить, существует ли данный ключ в словаре.

b = {'c': 3,'v': 2,'a': 8,'e': 12}
for i in b:
    print(i)

# наверное не 100% решение


# tasks 5
#
# Напишите программу на Python для перебора словарей с использованием циклов for
#

s = {'a': 22,'x': 89,'q': 11,'e': 78}
d = {'b': 20,'m': 19,'e': 41,'r': 28}
for i in s:
    for j in d:
        print(i,j)

# это не то но лучшего решения я не вижу (если было бы сказано словарь то другое решение,НО НАДПИСЬ СЛОВАРИ)

# TASk 6
# Напишите скрипт Python для генерации и печати словаря,
# который содержит число (от 1 до n) в форме (x, x * x).
# Перейти к редактору
# Пример словаря (n = 5):
# Ожидаемый результат: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# вообще не понимаю как решать но по эксперементирую примерно так

# наверное что то типо такого

# a = {value: for i in range(1,4),key: for j in range(1,4)}
# print(a)

# естественно это не работает

# списанный вариант
# n=int(input("Input a number "))
# 	d = dict()
#
# 	for x in range(1,n+1):
# 	    d[x]=x*x
#
# 	print(d)

#  понятно мог бы и догадаться сам
#  причем
#  конкретно так как фор здесь очевиден и если не вложенный то обычный бы точно сработал
